public class Algorithm_Q87 {
    /*
     * 이 문제는 prefix sum의 개념과 함께 수학적인 접근이 필요한 문제다.
     * 문제 링크는 아래와 같다.
     * https://leetcode.com/problems/subarray-sums-divisible-by-k/
     * 풀이를 확인해보자.
     */

    public int subarraysDivByK(int[] nums, int k) {
        // 이 문제는 prefix sum을 통해서 얻을 수 있는 수학적인 사실을 기반으로 풀어야 하는 문제다.
        // 문제를 해결하는 법 중에서도 수학적인 접근에 집중해야 풀 수 있는 문제로 아래 아이디어를 기억해야 한다.
        int answer = 0;
        int n = nums.length;
        int moduloLadder = 0;
        // 기본적으로 어떤 숫자든 나머지 연산을 하면 결과값은 0 ~ k-1 이 index로 떨어지게 된다.
        // 이를 바탕으로 현재의 부분 배열의 합은 결국 그 값의 나머지가 k로 나눌때 0 ~ k-1 이 된다는 사실에 주목해야 한다.
        int[] moduloGroup = new int[k];

        // 이 문제의 접근
        // 기본적으로 이 문제는 합산된 값들을 나머지 연산할 때 나머지 값이 어떻게 떨어지는지 관찰해서
        // 그 결과를 바탕으로 답을 얻는다.
        // 즉, 만약 현재 부분합이 나머지가 0이라면 1개만 있어도 이는 정답에 도달한다.
        // 그런데 나머지가 1 ~ k-1 사이라면
        // 이 숫자 2개가 존재할 때, 서로 뺴면 이렇게 된다.
        // k == 5 // a = 1, b = 6 => 2개 모두 나머지 연산 후 1이 답이 됨
        // 이때 b - a == 5 로 즉, 해당 2개 값을 선택하면 5로 나누어 떨어지는 값을 만들 수 있게 된다.
        // 이러한 나머지가 같은 값들의 무리를 바로 moduloGroup에 담아둬서 그 갯수를 계속 더하는 것이다.
        // 따라서, 0인덱스는 처음에 1로 세팅 나머지는 0으로 세팅하고
        // 이후 특정 인덱스에 나오는 케이스가 떨어지면
        // 이전에 해당 인덱스에 존재하는 모든 요소들과 조합 가능하니까
        // 그 요소들만큼 경우가 존재하므로 이를 다 더한다.
        // 예를 들어 1 6 에서 11이 나오게 되면
        // 1, 6 2가지와 조합되서 2개의 결과가 나온다
        // 1 6 6일 떄도 11이 나오면 1,6,6 3번을 만들 수 있다.
        // 이를 코드로 만들면 아래와 같다.

        // 기본적으로 0으로 나누어 떨어 진다면 1개만 있어도 정답이 되므로 일단 0번 인덱스에는
        // 1로 세팅한다.
        moduloGroup[0] = 1;

        for(int i = 0; i < n; i++) {
            // nums[i]에 나머지 값에 k를 더하는 이유는 혹시 나머지가 음수라면, 이를 양수로 바꿔서 처리하기 위함이다.
            moduloLadder = (moduloLadder + nums[i] % k + k) % k;

            answer = answer + moduloGroup[moduloLadder];
            moduloGroup[moduloLadder] += 1;
        }

        return answer;
    }
}
